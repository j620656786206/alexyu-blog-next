---
title: React Component Design - State Reducer
description: React Component Design - State Reducer
date: 2023-10-12
slug: react-component-design-state-reducer
type: Post
tags:
  - react
  - component design
  - design pattern
  - state reducer
---

`Render props`è®“ä½¿ç”¨è€…å¯ä»¥é€éŽstateåŽ»æŽ§åˆ¶UIçš„é¡¯ç¤ºï¼Œ

`State Reducer`å‰‡æ˜¯è®“ä½¿ç”¨è€…æŽ§åˆ¶`action`è§¸ç™¼æ™‚çš„é‚è¼¯ã€‚

æƒ³åƒä»Šå¤©æœ‰éœ€æ±‚è¦è®“`Toggle`å…ƒä»¶åªèƒ½è¢«toggle 3æ¬¡ï¼Œæˆ‘å€‘çš„ç¨‹å¼ç¢¼è©²å¦‚ä½•ä¿®æ”¹?

æœ€ç›´è¦ºçš„åšæ³•å¯èƒ½æ˜¯å‚³å…¥ä¸€å€‹toggleæ¬¡æ•¸é™åˆ¶çš„propsçµ¦Toggleï¼Œè®“ToggleåŽ»æª¢æŸ¥æ˜¯å¦æœ‰è¶…éŽæ¬¡æ•¸

```jsx
class Toggle extends React.Component {
  static defaultProps = {
    onToggle: () => {},
    onReset: () => {},
    initialOn: false
  };
  // å…ƒä»¶å…§éƒ¨å¤šä¸€å€‹ toggleTimes ä¾†æŽ§åˆ¶ç›®å‰çš„ toggle æ¬¡æ•¸
  initialState = { on: this.props.initialOn, currentToggleTimes: 0 };

  state = this.initialState;

  reset = () =>
    this.setState(this.initialState, () =>
      this.props.onReset(this.initialState)
    );

  toggle = () => {
    // æ¯æ¬¡ toggle æ™‚åˆ¤æ–·æœ‰æ²’æœ‰è¶…éŽä½¿ç”¨è€…å®šç¾©çš„ toggle æ¬¡æ•¸ä¸Šé™
    if (this.state.currentToggleTimes >= this.props.toggleTimes) {
      console.log('toggle too much')
      return;
    }
    this.setState(
      ({ on }) => ({
        on: !on,
        currentToggleTimes:this.state.currentToggleTimes + 1 }),
      () => this.props.onToggle(this.state.on),
    );
  }
  // ...other methods
}
```

ä½†ä½¿ç”¨è€…çš„éœ€æ±‚ç¸½æ˜¯æœƒè®Šå‹•ï¼Œå‡å¦‚ä»–çªç„¶é–“ä¹Ÿæƒ³æŽ§åˆ¶ `reset` çš„æ¬¡æ•¸æ€Žéº¼è¾¦? æˆ–è€…æ˜¯ä½¿ç”¨è€…åœ¨é»žæ“Š`toggle`çš„æ™‚å€™éœ€è¦å…ˆæ‰“apiæˆ–è€…æ ¹æ“šåˆ¥çš„è³‡æ–™è·Ÿç‹€æ…‹æ‰èƒ½æ±ºå®šæœ€å¾Œçš„`on`ç‹€æ…‹ï¼Œé‚£æˆ‘å€‘ä¸å°±æ”¹ä¸å®Œäº†ï¼Ÿé€™æ™‚å€™å¯ä»¥æ›å€‹è§’åº¦æ€è€ƒï¼Œè‹¥èƒ½å°‡`Toggle`çš„ç‹€æ…‹å¾€ä¸Šå‚³å‡ºä¾†çµ¦ä½¿ç”¨å®ƒçš„åœ°æ–¹ï¼Œè®“ä½¿ç”¨å®ƒçš„åœ°æ–¹æ±ºå®š`Toggle`æœ€çµ‚çš„ç‹€æ…‹ï¼Œå•é¡Œæ˜¯ä¸æ˜¯å°±è§£æ±ºäº†ï¼Ÿ

# stateReducer

ä¾†çœ‹çœ‹`Toggle`è©²æ€Žéº¼è¢«ä½¿ç”¨çš„ç¯„ä¾‹

```jsx
class Usage extends React.Component {
  static defaultProps = {
    onToggle: (...args) => console.log('onToggle', ...args),
    onReset: (...args) => console.log('onReset', ...args),
  }

  initialState = { timesClicked: 0 }

  state = this.initialState

  handleToggle = (...args) => {
    this.setState(({ timesClicked }) => ({
      timesClicked: timesClicked + 1,
    }))
    this.props.onToggle(...args)
  }

  handleReset = (...args) => {
    this.setState(this.initialState)
    this.props.onReset(...args)
  }

  toggleStateReducer = (state, changes) => {
    if (this.state.timesClicked >= 4) {
      return {...changes, on: false}
    }

    return changes
  }

  render() {
    const { timesClicked } = this.state

    return (
      <Toggle
        stateReducer={this.toggleStateReducer}
        onToggle={this.handleToggle}
        onReset={this.handleReset}
      >
        {toggle => (
          <div>
            <Switch
              {...toggle.getTogglerProps({
                on: toggle.on,
              })}
            />
            {timesClicked > 4 ? (
              <div data-testid="notice">
                Whoa, you clicked too much!
                <br />
              </div>
            ) : timesClicked > 0 ? (
              <div data-testid="click-count">
                Click count: {timesClicked}
              </div>
            ) : null}
            <button onClick={toggle.reset}>Reset</button>
          </div>
        )}
      </Toggle>
    )
  }
}
```

`Toggle`å…ƒä»¶æ–°å¢žäº†ä¸€å€‹propså«`stateReducer`ï¼Œ ç¬¬ä¸€å€‹åƒæ•¸æ˜¯Toggleå…ƒä»¶ç›®å‰çš„stateï¼Œç¬¬äºŒå€‹åƒæ•¸`changes`å‰‡æ˜¯`Toggle`å…ƒä»¶åœ¨åŸ·è¡Œ`setState`æ™‚æ‰€æŽ¥å—çš„è®ŠåŒ–ã€‚

ä¾†çœ‹çœ‹`Toggle`å…ƒä»¶çš„è©³ç´°å¯¦ä½œ

```jsx
class Toggle extends React.Component {
  static defaultProps = {
    initialOn: false,
    onReset: () => {},
    stateReducer: (state, changes) => changes,
  }

  initialState = {on: this.props.initialOn}

  state = this.initialState

  internalSetState(changes, callback) {
    this.setState(state => {
      // handle function setState call
      const changesObject =
        typeof changes === 'function' ? changes(state) : changes

      // apply state reducer
      const reducedChanges =
        this.props.stateReducer(state, changesObject) || {}

      // return null if there are no changes to be made
      // (to avoid an unecessary rerender)
      return Object.keys(reducedChanges).length
        ? reducedChanges
        : null
    }, callback)
  }

  reset = () =>
    this.internalSetState(this.initialState, () =>
      this.props.onReset(this.state.on),
    )

  toggle = () =>
    this.internalSetState(
      ({ on }) => ({ on: !on }),
      () => this.props.onToggle(this.state.on),
    )

  getTogglerProps = ({ onClick, ...props } = {}) => ({
    onClick: callAll(onClick, this.toggle),
    'aria-pressed': this.state.on,
    ...props,
  })

  getStateAndHelpers() {
    return {
      on: this.state.on,
      toggle: this.toggle,
      reset: this.reset,
      getTogglerProps: this.getTogglerProps,
    }
  }

  render() {
    return this.props.children(this.getStateAndHelpers())
  }
}
```

é€™é‚Šæä¾›åŽŸä½œè€…Kent C. Doddsåå¥½çš„`internalSetState`å¦å¤–ä¸€ç¨®å¯«æ³•

```jsx
internalSetState(changes, callback) {
	this.setState(currentState => {
		return [changes]
			.map(c => typeof c === 'function' ? changes(currentState) : c)
      .map(c => this.props.stateReducer(currentState, c) || {})
      .map(c => Object.keys(reducedChanges).length ? c : null)[0]
	})
}
```

# With Types

å¯èƒ½æœƒæœ‰äººç–‘å•é€™å€‹`reducer`çš„å½¢ç‹€æ€Žéº¼è·Ÿ`[redux](https://redux.js.org/)`çš„æ¨£å­ä¸å¤ªä¸€æ¨£ï¼Œæ‡‰è©²è¦æœ‰`type`ï¼Œ`payload`ä¹‹é¡žçš„å­—çœ¼ï¼Œé€™é‚Šå¯¦ä½œåŠ ä¸Š`type`ï¼Œå…ˆä¾†çœ‹çœ‹æ€Žéº¼ä½¿ç”¨`Toggle`

```jsx
class Usage extends React.Component {
  static defaultProps = {
    onToggle: (...args) => console.log('onToggle', ...args),
    onReset: (...args) => console.log('onReset', ...args),
  }

  initialState = { timesClicked: 0 }

  state = this.initialState

  handleToggle = (...args) => {
    this.setState(({ timesClicked }) => ({
      timesClicked: timesClicked + 1,
    }))
    this.props.onToggle(...args)
  }

  handleReset = (...args) => {
    this.setState(this.initialState)
    this.props.onReset(...args)
  }

  toggleStateReducer = (state, changes) => {
    if (changes.type === 'forced') {
      return changes
    }
    if (this.state.timesClicked >= 4) {
      return {...changes, on: false}
    }
    return changes
  }

  render() {
    const { timesClicked } = this.state

    return (
      <Toggle
        stateReducer={this.toggleStateReducer}
        onToggle={this.handleToggle}
        onReset={this.handleReset}
        ref={this.props.toggleRef}
      >
        {({ on, toggle, reset, getTogglerProps }) => (
          <div>
            <Switch
              {...getTogglerProps({
                on: on,
              })}
            />
            {timesClicked > 4 ? (
              <div data-testid="notice">
                Whoa, you clicked too much!
                <br />
                <button onClick={() => toggle({type: 'forced'})}>
                  Force Toggle
                </button>
                <br />
              </div>
            ) : timesClicked > 0 ? (
              <div data-testid="click-count">
                Click count: {timesClicked}
              </div>
            ) : null}
            <button onClick={reset}>Reset</button>
          </div>
        )}
      </Toggle>
    )
  }
}
```

`Toggle`å…ƒä»¶çš„å¯¦ä½œå¦‚ä¸‹

```jsx
class Toggle extends React.Component {
  static defaultProps = {
    initialOn: false,
    onReset: () => {},
    stateReducer: (state, changes) => changes,
  }

  // ðŸ’° any time I use a string as an identifier for a type,
  // I prefer to give it a variable name. That way folks who
  // want to reference the type can do so using variable which
  // will help mitigate the problems of indirection.
  static stateChangeTypes = {
    reset: '__toggle_reset__',
    toggle: '__toggle_toggle__',
  }

  initialState = { on: this.props.initialOn }

  state = this.initialState

  internalSetState(changes, callback) {
    this.setState(state => {
      // handle function setState call
      const changesObject =
        typeof changes === 'function' ? changes(state) : changes

      // apply state reducer
      const reducedChanges =
        this.props.stateReducer(state, changesObject) || {}

      // remove the type so it's not set into state
      const { type: ignoredType, ...onlyChanges } = reducedChanges

      // return null if there are no changes to be made
      return Object.keys(onlyChanges).length ? onlyChanges : null
    }, callback)
  }

  reset = () =>
    this.internalSetState(
      {...this.initialState, type: Toggle.stateChangeTypes.reset},
      () => this.props.onReset(this.state.on),
    )

  toggle = ({type = Toggle.stateChangeTypes.toggle} = {}) =>
    this.internalSetState(
      ({ on }) => ({ type, on: !on }),
      () => this.props.onToggle(this.state.on),
    )

  getTogglerProps = ({ onClick, ...props } = {}) => ({
    onClick: callAll(onClick, () => this.toggle()),
    'aria-pressed': this.state.on,
    ...props,
  })

  getStateAndHelpers() {
    return {
      on: this.state.on,
      toggle: this.toggle,
      reset: this.reset,
      getTogglerProps: this.getTogglerProps,
    }
  }
  render() {
    return this.props.children(this.getStateAndHelpers())
  }
}
```